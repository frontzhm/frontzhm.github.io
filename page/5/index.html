<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="frontzhm, zhm, huahua, hua_hua" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="hello world">
<meta property="og:type" content="website">
<meta property="og:title" content="花花的博客">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="花花的博客">
<meta property="og:description" content="hello world">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="花花的博客">
<meta name="twitter:description" content="hello world">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title> 花花的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?60f2cb5747a596a24f2a053f1650c30b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">花花的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/03/computer_composition_baisc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/02/03/computer_composition_baisc/" itemprop="url">
                  计算机组成原理的概述
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-03T18:40:10+08:00">
                2021-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/02/03/computer_composition_baisc/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/02/03/computer_composition_baisc/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看一些计算机基础课，边看边输出总结吧，方便自己查阅，也希望对读者有用。</p>
<h2 id="计算机发展的四个阶段"><a href="#计算机发展的四个阶段" class="headerlink" title="计算机发展的四个阶段"></a>计算机发展的四个阶段</h2><ul>
<li>电子管计算机（第二次世界大战因为破解密文发明的）：1946-1957</li>
<li>晶体管计算机：1957-1964</li>
<li>集成电路计算机（IBM可以卖电脑，且操作系统有了雏形）：1964-1980</li>
<li>超大规模集成电路计算机（乔布斯发明了一代苹果电脑）：1980-现在</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/018c827556ac4d139cbb480070075882~tplv-k3u1fbpfcp-zoom-1.image" alt="computer1.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d28c944e479412189abeaef759662ee~tplv-k3u1fbpfcp-zoom-1.image" alt="computer2.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db8d7dc06c6b476fa63a2fac6cfcc03a~tplv-k3u1fbpfcp-zoom-1.image" alt="computer3.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af0fa424fbf45428987325d01c0cc73~tplv-k3u1fbpfcp-zoom-1.image" alt="computer4.png"></p>
<h3 id="微型计算机的发展历史"><a href="#微型计算机的发展历史" class="headerlink" title="微型计算机的发展历史"></a>微型计算机的发展历史</h3><p>集成电路计算机之后就算是微型计算机了</p>
<ul>
<li>单核CPU：1971-现在</li>
<li>多核CPU：2005-现在</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b0d0aa987b34dc9905f6890695f2c93~tplv-k3u1fbpfcp-zoom-1.image" alt="computer6.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/070fd63ca8064d39b21edf514c2d6936~tplv-k3u1fbpfcp-zoom-1.image" alt="computer7.png"></p>
<h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><ul>
<li>超级计算机：运算速度超过TFlops/s（每秒一万亿次浮点运算）</li>
<li>大型计算机：IOE基本包揽（IBM ORACLE EMC，但维护费用很高，阿里在2008年提出”去IOE“，于是有了2009年的阿里云）</li>
<li>迷你计算机（服务器）：联想、华为、浪潮等生产</li>
<li>工作站：性能比普通计算机强劲，适用于图形或视频工作者</li>
<li>微型计算机：就我们普通用的电脑，分为台式机、笔记本、一体机</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e07537cdccc4abeae795f4704e1db2b~tplv-k3u1fbpfcp-zoom-1.image" alt="computer8.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da08e61dba240fea3bd1ab0026259da~tplv-k3u1fbpfcp-zoom-1.image" alt="computer9.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0d945bd00104262bb41df457e040306~tplv-k3u1fbpfcp-zoom-1.image" alt="computer10.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b703bc0476b8460a97ed55f93f5bc94e~tplv-k3u1fbpfcp-zoom-1.image" alt="computer11.png"></p>
<h2 id="计算机的体系"><a href="#计算机的体系" class="headerlink" title="计算机的体系"></a>计算机的体系</h2><p>早期的计算机功能单一，想要<strong>切换功能</strong>，需要<strong>重新</strong>接电路之类的复杂操作。</p>
<p>冯诺依曼把程序指令和运行数据<strong>存储</strong>起来，使得计算机从专用电路计算机发展成为<strong>通用</strong>电路计算机，这也称为也成为<code>冯诺依曼体系</code>。</p>
<p>为了实现能切换功能，冯诺依曼体系的主要组成部分如下：</p>
<ul>
<li>存储器：存储程序和数据</li>
<li>控制器：切换程序</li>
<li>运算器：运算</li>
<li>输入设备：把需要的程序和数据送至计算机</li>
<li>输出设备：按照要求把处理输出给用户</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c1d1f5fd9bf4406954b03c749dad8fe~tplv-k3u1fbpfcp-zoom-1.image" alt="computer12.png"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76a887095aad4195bbac548d3ec48997~tplv-k3u1fbpfcp-zoom-1.image" alt="computer13.png"></p>
<p>冯诺依曼的瓶颈：CPU是由控制器和运算器组成，而CPU运行速度<strong>远高于</strong>存储器的速率，导致CPU经常空转，从而计算机性能无法提升</p>
<p>现代计算机这基础上进行了修改，将存储器放进CPU，以存储器为核心，根据局部性原理设计了存储器的层次结构，大幅提升计算机性能。</p>
<h2 id="计算机的编程语言"><a href="#计算机的编程语言" class="headerlink" title="计算机的编程语言"></a>计算机的编程语言</h2><p>人类语言：i am yan<br>计算机语言：01010110  </p>
<p>两者并不相通，为了让计算机明白人类的语言，就需要翻译或者解释人类语言。</p>
<p>所以编程语言分为编译型语言和解释型语言。</p>
<ul>
<li>编译型：程序代码在编译阶段，提前翻译成较低层次的编程语言逻辑（整体），在运行时直接运行。如C++、 OC、GoLang</li>
<li>解释型：程序代码在运行阶段，<strong>逐行</strong>翻译成较低层次的编程语言去执行。如PHP、Python、Javascript</li>
<li>有些语言则是两者的混合，C#、Java，如：Java =&gt; 编译 =&gt; JVM字节码（JVM虚拟机） =&gt; 解释 =&gt; 机器码</li>
</ul>
<h2 id="计算机的层次结构"><a href="#计算机的层次结构" class="headerlink" title="计算机的层次结构"></a>计算机的层次结构</h2><p>先说三个概念</p>
<ul>
<li>机器语言：是方便计算机理解和运行的编程语言，一般程序员无法理解</li>
<li>汇编语言：是方便程序员描述硬件逻辑的编程语言，与底层硬件接近</li>
<li>高级语言：是程序员接触的高级语言，与人类语言接近</li>
</ul>
<p>为了理解计算机的整体体系，将其大致划分为7个层次结构，从下到上：</p>
<ul>
<li>硬件逻辑层：门、触发器等逻辑电路组成，属于电子工程领域</li>
<li>微程序机器层：编程语言是微指令集，微指令所组成的微程序直接交由硬件执行，由硬件公司的程序员编写</li>
<li>传统机器层：编程语言是CPU指令集，编程语言和硬件直接相关，不同架构的CPU使用不同的CPU指令集</li>
<li>操作系统层：向上提供操作界面，向下对接了指令系统管理硬件资源，是位于软件和硬件之间的适配层</li>
<li>汇编语言层：编程语言是汇编语言，经过汇编器可以直接翻译成可执行的机器语言</li>
<li>高级语言层：编程语言是程序员接触的高级语言，如Python、Java、GoLang、C/C++</li>
<li>应用层：满足计算机针对某种用途而专门设计的APP，如Word</li>
</ul>
<!-- 一条机器指令对应一个微程序 一个微程序对应一组微指令 -->
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c8789da29c4413a2c60c7af84d0d91~tplv-k3u1fbpfcp-zoom-1.image" alt="computer14"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1994e6127f246b19e8065010e17756d~tplv-k3u1fbpfcp-zoom-1.image" alt="computer16"></p>
<h2 id="计算机的计算单位"><a href="#计算机的计算单位" class="headerlink" title="计算机的计算单位"></a>计算机的计算单位</h2><p>主要是容量单位和速度单位</p>
<h3 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h3><p>计算机在物理层面，用高低电平记录信息，高表示1低表示0，只认识0/1两种状态，0/1也就是一个比特位bit</p>
<p>1个bit能表示的信息太少了，后来用8个bit表示一个字节，也就是 1Byte = 8bits</p>
<p>后来Byte也不足以描述容量，于是有了更大的单位</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/529f684298234800aaab9a8829dda2fc~tplv-k3u1fbpfcp-zoom-1.image" alt="computer17"></p>
<p>1G = 1024MB = 1024*1024KB = 1024*1024*1024B = 1024*1024*1024*8bits</p>
<p>也就是 <code>1G = 1024^3B</code></p>
<p>这里有个梗，买电脑的时候说的500G硬盘，到家打开发现只有465G？</p>
<p>因为厂商的<code>1G = 1000^3B</code>，换算成真实的容量<code>500*1000^3/1024^3 = 465G</code></p>
<!-- 1024是2的10次方 -->
<h3 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h3><ul>
<li>网络速度：描述网络速度的常用单位是比特率，是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，每秒传送数据就越多。<br>就是Mbit/s，100Mbit/s = (100/8)MB/s = 12.5MB/s。也就是100M光纤，峰值只有12M/s。</li>
<li>CPU速度：描述CPU速度的常用单位是Hz，表示是每秒中的周期性变动重复次数的计量，也可以简单理解为在单位时间内完成振动的次数。如蝴蝶的翅膀震动的频率是15Hz，表示1s中翅膀震动15次，蜜蜂是400Hz。CPU这里表示高低电平变换的频率。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b75dcd57d51e4958b54170b715ab8b09~tplv-k3u1fbpfcp-zoom-1.image" alt="computer18"></p>
<p>再说一个梗：为啥光纤说的百兆宽带，实际使用中只有12M多？</p>
<p>因为：100Mbps = 100Mbit/s = (100/8)MB/s = 12.5MB/s</p>
<p>为什么人能听到蜜蜂的声音听不到蝴蝶的声音？</p>
<p>因为：人耳听到的范围是20Hz~2wHz</p>
<h2 id="计算机的字符和编码集"><a href="#计算机的字符和编码集" class="headerlink" title="计算机的字符和编码集"></a>计算机的字符和编码集</h2><h3 id="字符编码集的历史"><a href="#字符编码集的历史" class="headerlink" title="字符编码集的历史"></a>字符编码集的历史</h3><ul>
<li>ASCII编码集：共有128个字符（95个可打印，33不可打印的字符），128 = 2^7，所以使用7个bits就可以表示所有的ASCII码</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fc6774f13ac4f84a3ac18fc72c848de~tplv-k3u1fbpfcp-zoom-1.image" alt="computer20"></p>
<ul>
<li>扩充ASCII编码集：随着计算机开始普及，一些字符就不能用ASCII码表示了，如π，于是开始将7个bits变成8个bits，从而可以表示255个字符</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92af54cc6a64c1f9dc621a78e246c8b~tplv-k3u1fbpfcp-zoom-1.image" alt="computer21"></p>
<ul>
<li>Unicode标准：普及到各个国家，需要兼容各个国家的语言，于是有了unicode标准，可以用不同的编码实现，比如UTF-8、UTF-16、UTF-32。编程推荐<code>utf-8</code>。</li>
</ul>
<h3 id="中文编码集的发展"><a href="#中文编码集的发展" class="headerlink" title="中文编码集的发展"></a>中文编码集的发展</h3><ul>
<li>GB2312：1980年诞生的，但是不符合国际标准，外国人访问中国网站，因为本地没有，所以会乱码</li>
<li>GBK：1995年诞生的，向下兼容了<code>GB2312</code>且向上支持国际ISO标准，收录<strong>21003</strong>个字符，支持中日韩汉字</li>
</ul>
<p>一个问题，假设有10000个汉字，6000个日本字，3000个韩国字，1000个特殊字符，如果让你设计一套通用的编码集，请问每个字至少几个比特位？</p>
<p>1个比特位，只能表示2种信息，0表示1种，1表示1种。<br>2个比特位，能表示4种信息，00、01、10、11<br>对，就是排列组合，n个比特位能表示2^n种信息<br>于是，10000+6000+3000+1000 = 20000 &lt; 2^15，也就是15个比特位</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>本文图片是截图自<a href="https://coding.imooc.com/lesson/355.html" target="_blank" rel="noopener">咚咚呛老师的编程基础课</a><br>本文多数是总结性文字，也部分引用课程文字~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/22/exam_browser/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/22/exam_browser/" itemprop="url">
                  简单理解浏览器的工作
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-22T20:21:24+08:00">
                2021-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/22/exam_browser/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/22/exam_browser/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>浏览器既是搬运工，也是翻译官。</p>
<ul>
<li>将枯燥的网络资源(html css js)从服务器“搬”到本地</li>
<li>将资源“翻译”成五彩的页面</li>
<li>接受并反馈用户的交互</li>
</ul>
<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>翻译的工作，最主要是由，浏览器的<code>渲染引擎</code>做的。</p>
<p>翻译的过程如下：</p>
<ul>
<li>访问网址的时候，服务器一般会首先返回 html 文件</li>
<li>渲染引擎，开始解析<code>html</code>文件，生成<code>DOM</code>树。在这过程中遇到其他资源（css img js），会发出新的请求</li>
<li>识别并加载所有的 <code>CSS</code> 样式信息，生成<code>CSSOM</code>树，注意这里的样式会添加到<code>DOM</code>树的各个节点</li>
<li>将<code>DOM</code>树和<code>CSSOM</code>树合并，<strong>将不可见的元素剔除</strong>，生成<code>render</code> 树（:after :before 伪元素会在此时被构建到 DOM 树中）</li>
<li>计算页面中所有元素的相对位置、大小等信息，就有了<code>盒模型</code></li>
<li>开始把每一个页面图层转换为像素，并对所有的媒体文件进行解码，然后五彩的<strong>页面</strong>就显示出来了</li>
</ul>
<blockquote>
<p>总结下：<code>DOM</code>树 =&gt; <code>CSSOM</code>树 =&gt; <code>render</code>树 =&gt; 布局 =&gt; 绘制</p>
</blockquote>
<h2 id="重绘、重排、图层"><a href="#重绘、重排、图层" class="headerlink" title="重绘、重排、图层"></a>重绘、重排、图层</h2><p>页面不会一成不变的，JS 可以随意操作 DOM，从而会让渲染引擎再次翻译。</p>
<p>不同的操作，翻译成本不同，主要分为两种操作：</p>
<ul>
<li>重排(回流)：操作引发了 DOM 几何尺寸的变化（修改元素的宽高或隐藏元素等）时，于是需要重新计算元素 的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再绘制出来。<br>对应的流程：可能更新<code>DOM</code>树 =&gt; 更新<code>CSSOM</code>树 =&gt; 更新<code>render</code>树 =&gt; 重新布局 =&gt; 重新绘制</li>
<li>重绘：操作只修改了未影响元素几何属性的样式（比如修改了颜色或背景色）时，就会跳过计算、直接绘制。<br>对应的流程： 更新<code>CSSOM</code>树 =&gt; 更新<code>render</code>树 =&gt; 重新绘制</li>
</ul>
<p>引发重排的操作：</p>
<ul>
<li>修改元素的几何属性</li>
<li>改变 DOM 的结构，增减、移动等</li>
<li>获取一些特定属性的值：offsetTop|Left|Width|Height、scrollTop|Left|Width|Height、<br>clientTop|Left|Width|Height，这些属性均通过<strong>即时计算</strong>得到，于是浏览器为了获取这些值，也会进行回流</li>
</ul>
<p>重排的代价很昂贵，尽量减少重排的操作，频繁引发重排，会让页面卡顿滴~</p>
<h2 id="事件循环机制-event-loop"><a href="#事件循环机制-event-loop" class="headerlink" title="事件循环机制 event-loop"></a>事件循环机制 event-loop</h2><p>以上还没提到 JS 文件的翻译，JS 是由 JS 引擎翻译的。</p>
<p>先提一些名词：</p>
<ul>
<li>宏任务（macro-task)队列：script（整体代码）、setTimeout、setInterval 等</li>
<li>微任务(microtask) 队列：Promise 等</li>
<li>函数调用栈</li>
</ul>
<p>JS 引擎从开始执行 Script 脚本的时候，这本身就是一个宏任务，然后创建全局上下文，进栈</p>
<ul>
<li>如果遇到<code>Promise</code>的<code>then</code>代码，不会直接执行，会在此宏任务的内部，开启一个微任务队列，这个<code>then任务</code>就是排队的第一人</li>
<li>如果遇到<code>setTimeout/setInterval</code>，不会直接执行，会另外开启一个宏任务，排在当前宏任务的后面，如果这个<code>setTimeout</code>里面再遇到<code>then</code>，也会在它的内部开启一个微任务队列</li>
<li>如果当前的宏任务的同步代码执行完了，会依次执行当前宏任务内部的，微任务队列里的任务</li>
<li>如果当前的宏任务的同步代码执行完了，微任务队列里的任务也执行完了，就会执行下一个宏任务</li>
<li>函数调用栈，每次执行一个函数，就创建了函数上下文，进栈，执行完，出栈，没啥说的，之前说过了</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// s-1</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1-1"</span>);</span><br><span class="line">    <span class="comment">// p-1</span></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"2-1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"1-2"</span>);</span><br><span class="line">  <span class="comment">// p-2</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1-3"</span>);</span><br><span class="line">    <span class="comment">// s-2</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"3-1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">app();</span><br><span class="line"><span class="comment">// 1-2 1-3 1-1 2-1 3-1</span></span><br></pre></td></tr></table></figure>
<p>画了个图，希望能帮助读者理解：</p>
<p><img src="https://blog-huahua.oss-cn-beijing.aliyuncs.com/blog/code/task1.png" alt="task1"></p>
<!-- - 宏任务（macro-task)队列：script（整体代码）、setTimeout、setInterval、 setImmediate、I/O 操作等。
- 微任务(microtask) 队列：Promise、process.nextTick、MutationObserver
- 函数调用栈 -->

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/22/exam_dom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/22/exam_dom/" itemprop="url">
                  DOM
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-22T13:16:53+08:00">
                2021-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/22/exam_dom/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/22/exam_dom/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DOM 全称是<code>Document object model</code>，翻译为，文档对象模型，是 HTML 和 XML 文档的编程接口。<br>把 HTML 中各个标签定义出的元素以对象的形式包装起来，然后可通过 JS 对标签进行增删改查。</p>
<p>DOM 结构以树的形态存在，最小单位是节点。</p>
<h2 id="DOM的节点类型"><a href="#DOM的节点类型" class="headerlink" title="DOM的节点类型"></a>DOM的节点类型</h2><p>节点类型主要有：</p>
<ul>
<li>Document：指这份文件，也就是这份 HTML 档的开端。当浏览器载入 HTML 文档, 它就会成为 Document 对 象。</li>
<li>Element：指 HTML 文件内的各个标签，像是<code>&lt;div&gt;、&lt;span&gt;</code> 这样的各种 HTML 标签定义的元素</li>
<li>Text：指被各个标签包起来的文字，像是<code>&lt;div&gt;就是这段文字&lt;/div&gt;</code></li>
<li>Attribute：指元素的特性，就是各个标签上的属性</li>
<li>Comment：指文档注释<code>&lt;!-- 注释 --&gt;</code></li>
</ul>
<h2 id="DOM-的增删改查"><a href="#DOM-的增删改查" class="headerlink" title="DOM 的增删改查"></a>DOM 的增删改查</h2><ul>
<li>增：document.createElement(‘span’)、parent.appendChild(x)</li>
<li>删：y.parent.removeChild(y)</li>
<li>改：x.someAttr = ‘…’、y.parent.insertBefore(appendElement,ele)</li>
<li>查 querySelector、querySelectorAll、getElementById/ClassName/TagName</li>
</ul>
<h2 id="DOM-事件体系"><a href="#DOM-事件体系" class="headerlink" title="DOM 事件体系"></a>DOM 事件体系</h2><p>先说下专有名词：</p>
<ul>
<li>事件：在浏览器里的动作，可以是用户触发的，也可以是浏览器触发的。如<code>click mouseover</code></li>
<li>事件监听函数：也叫<code>事件处理程序</code>，是事件发生后，浏览器如何响应，其实就是用来应答事件的函数，。</li>
<li>事件流（事件的流向）：事件在页面中传播的顺序</li>
</ul>
<p>体系主要从四方面理解：</p>
<ul>
<li>DOM 事件流，分 3 个阶段：事件捕获阶段、目标阶段、冒泡阶段（<strong>V</strong>字形）</li>
<li>事件对象：当事件 DOM 元素中穿梭时，会触发当前元素上绑定的相应事件处理函数，此时会产生一个事件对象 event 作为处理函数的入参。其囊括了与事件有关的信息，比如由触发事件的元素、事件的类型等</li>
<li>自定义事件</li>
<li>事件代理</li>
</ul>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>e.currentTarget 和 e.target 事件对象两个属性很容易混淆，简单说下联系和区别：</p>
<ul>
<li>本质上<code>e.currentTarget</code>是绑定事件的当前元素，<code>e.target</code>是触发事件的元素。</li>
<li>因为有捕获和冒泡阶段，所以这两可能不一样</li>
<li>假设有个<code>div</code>，里面有一个 span 标签和 b 标签，给 div 绑定点击事件的时候，<code>e.currentTarget</code>则<strong>始终</strong>是 div，但是如果点击的是<code>span</code>标签，<code>e.target</code>就是<code>span</code>，</li>
<li>重点！！！如果点击这两标签之外的但又是 div 内部的区域，<code>e.target</code>就是<code>div</code>，此时和<code>e.currentTarget</code>是一致的</li>
</ul>
<p>常用的两个方法：</p>
<ul>
<li><code>event.stopPropagation()</code>，让事件不再冒泡，将事件的影响面控制在目标元素这个范围内</li>
<li><code>event.preventDefault()</code>，阻止浏览器的默认动作，比如点击 a 标签会跳转</li>
</ul>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>除了浏览器的默认事件<code>click</code>之类，开发者可以自己创建新事件。</p>
<p>比如现在有三个同级元素<code>a b c</code>，点击 a 之后，想要 b 和 c 也知道 a 被点击。</p>
<p>那么可以创建一个<code>clickA</code>事件，然后让 b 和 c 绑定这个事件，点击 a 之后就让 b 和 c 触发这个事件</p>
<p>看个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c"</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 新建一个自定义事件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> clickA = <span class="keyword">new</span> Event(<span class="string">"clickA"</span>);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">"#a"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// a点击之后，就是clickA事件触发的时候，但浏览器不认识它，所以感知和派发，可以自己来实现：</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">"#b"</span>).dispatchEvent(clickA);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">"#c"</span>).dispatchEvent(clickA);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">"#b"</span>).addEventListener(<span class="string">"clickA"</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.querySelector(<span class="string">"#b"</span>).addEventListener(<span class="string">"clickA"</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>事件在冒泡阶段的时候，会将事件一层层传播，直到整个文档。而从事件对象的<code>target</code>属性，可以知道传播到哪里了。</p>
<p>于是，利用事件的冒泡特性，可以将多个子元素的同一类型的监听逻辑，合并到父元素上通过一个监听函数来管理的行 为，就是事件代理。</p>
<p>通过事件代理，我们可以减少内存开销、简化注册步骤，大大提高开发效率。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="javascript">  ul.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里点击不同的li就会输出相应的内容，e.target就是正在点击的元素</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e.target.innerHTML);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/21/exam_es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/21/exam_es6/" itemprop="url">
                  细心使用es6新增的语法
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-21T17:53:43+08:00">
                2021-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/21/exam_es6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/21/exam_es6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><ul>
<li>块作用域里，和函数作用域类似，存在变量提升</li>
<li><code>let/const</code>作用于块作用域</li>
<li><code>let</code>也存在变量提升，但是 JS 不允许你在声明语句前使用，声明语句前都是暂时性死区</li>
<li><code>const</code>声明必须赋值，普通值不可被修改，引用类型的值不可修改<strong>引用指向</strong>，但是可以对其中的属性修改</li>
<li><code>let/const</code> 可以替换掉<code>var</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(name)</span><br><span class="line"> <span class="keyword">var</span> name =<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这里会报错哟，因为块作用域存在变量提升，但是这里是暂时性死区，访问不到name</span></span><br><span class="line"> <span class="built_in">console</span>.log(name)</span><br><span class="line"> <span class="keyword">let</span> name =<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依旧是1,块作用域有自己的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="comment">// 报错,没赋值</span></span><br><span class="line"><span class="keyword">const</span> a</span><br><span class="line"><span class="keyword">const</span> b =<span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 报错,修改引用指向</span></span><br><span class="line">obj = &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> arr= [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 这样是没问题的</span></span><br><span class="line">arr[<span class="number">1</span>]=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><ul>
<li>数组可以占位解构，注意严格和位置有关</li>
<li>对象和位置无关，和属性名称有关，可以<strong>重命名</strong>属性名称，也可解析<strong>嵌套</strong>结构</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 占位赋值</span></span><br><span class="line"><span class="keyword">const</span> [a, , c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 位置无关，属性名有关，可以重新命名新变量</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, <span class="attr">age</span>: newAge &#125; = &#123; <span class="attr">age</span>: <span class="number">10</span>, <span class="attr">name</span>: <span class="string">"yan"</span> &#125;;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(newAge);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">  classes: &#123;</span><br><span class="line">    stu: &#123; <span class="attr">name</span>: <span class="string">"Bob"</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可嵌套结构</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  classes: &#123;</span><br><span class="line">    stu: &#123; name, age &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = school;</span><br><span class="line"><span class="comment">// 24</span></span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br></pre></td></tr></table></figure>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符..."></a>扩展运算符<code>...</code></h2><ul>
<li>对象中的扩展运算符，常用于取出参数对象中的所有<strong>可遍历</strong>属性，拷贝到当前对象之中</li>
<li>数组中扩展运算，可以将一个数组转为用逗号分隔的参数序列，一般用途如下：<ul>
<li>把数组变成函数的参数</li>
<li>合并数组</li>
<li>利用 rest 参数(把零散的参数合并成一个数组，很适合用来处理参数不固定)</li>
<li>把类数组（类数组是有 length 属性的对象）转化为数组</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = &#123; <span class="attr">name</span>: <span class="string">"yan"</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> meCopy = &#123; ...me &#125;;</span><br><span class="line"><span class="comment">// &#123; name: "yan", age: 24 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(meCopy);</span><br><span class="line"><span class="comment">// ha he xi</span></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="string">"ha"</span>, <span class="string">"he"</span>, <span class="string">"xi"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line">multiple(...arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="comment">// 合并数组</span></span><br><span class="line"><span class="keyword">const</span> newArr = [...arr1, ...arr2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数，很适合用来处理参数不固定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">    result += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayLike = &#123; <span class="number">0</span>: <span class="string">"Bob"</span>, <span class="number">1</span>: <span class="string">"Lucy"</span>, <span class="number">2</span>: <span class="string">"Daisy"</span>, <span class="attr">length</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">// 类数组转化成数组，下面还有两种了解下</span></span><br><span class="line"><span class="keyword">const</span> arr = [...arrayLike];</span><br><span class="line"><span class="comment">// const arr = Array.prototype.slice.call(arrayLike);</span></span><br><span class="line"><span class="comment">// const arr = Array.from(arrayLike);</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符"><a href="#模板字符" class="headerlink" title="模板字符"></a>模板字符<code></code></h2><ul>
<li>可用<code>${}</code>这样简单的方式嵌入变量</li>
<li>在模板字符串中，空格、缩进、换行都会被保留 (超合适写 DOM 节点)</li>
<li>模板字符串完全支持“运算”式的表达式，你可以在<code>${}</code>里完成一些计算</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'yan'</span></span><br><span class="line"><span class="keyword">let</span> newName = <span class="string">`<span class="subst">$&#123;name&#125;</span> jiang`</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;列表项1&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;列表项2&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 顺利输出，不存在报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 可做计算</span></span><br><span class="line">  <span class="keyword">const</span> finalString = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span>`</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(finalString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 '1 + 2 = 3'</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="字符串的实用方法"><a href="#字符串的实用方法" class="headerlink" title="字符串的实用方法"></a>字符串的实用方法</h2><ul>
<li>存在性判定。以前只能用<code>indexOf&gt;-1</code>，现在可灵活使用<code>includes、startsWith、endsWith</code></li>
<li>自动重复。<code>repeat</code>方法让同一个字符串被连续复制多次</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">'ha'</span></span><br><span class="line"><span class="keyword">const</span> father = <span class="string">'xi he ha'</span></span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line">father.includes(son)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">father.startsWith(son)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">father.endsWith(son)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">'repeat '</span></span><br><span class="line"><span class="comment">// 复制3次</span></span><br><span class="line"><span class="keyword">const</span> repeated = sourceCode.repeat(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 'repeat repeat repeat '</span></span><br><span class="line"><span class="built_in">console</span>.log(repeated)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/20/exam_prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/20/exam_prototype/" itemprop="url">
                  理解，原型/原型链/new
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-20T19:54:20+08:00">
                2021-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/20/exam_prototype/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/20/exam_prototype/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文主要总结了大神的专栏，如果有不对之处，欢迎指正。</p>
<p>原型（Prototype）模式是一种设计模式，同时更是一种编程范式（programming paradigm）</p>
<h2 id="理解原型编程范式"><a href="#理解原型编程范式" class="headerlink" title="理解原型编程范式"></a>理解原型编程范式</h2><p>类是先抽象后具体，也就是必须先有类，之后才是实例，然后在关注具体层面的东西。比如 JAVA 中，类是它面向对象系统的根本。</p>
<p>原型是先具体后抽象，将相似实例关联到一个原型对象，从而囊括较为通用的行为和属性。基于此原型，通过 “复制” 来创建新对象。</p>
<p>JS 中，原型是面向对象系 统的根本。</p>
<p>JS 中怎么实现复制的呢？</p>
<p>JS 是通过使<strong>新对象</strong>保持对原型对象的<strong>引用</strong>来做到了 “复制”（就是新对象上面有 <strong>proto</strong>）。</p>
<p>JS 不是有 Class 么？</p>
<p>注意，JS 的 class 只是原型的语法糖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"肉骨头真好吃"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"肉骨头真好吃"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="理解原型与原型链"><a href="#理解原型与原型链" class="headerlink" title="理解原型与原型链"></a>理解原型与原型链</h2><p>原型编程范式的核心思想就是利用实例来描述对象，用<strong>实例</strong>作为定义对象和继承的基础。</p>
<p>JS 里，原型编程范式的体现就是基于<strong>原型链</strong>的继承，每个新对象都<strong>保留</strong>了对原型对象的引用。</p>
<ul>
<li>每个构造函数都拥有一个 <code>prototype</code> 属性，它指向构造函数的原型对象，这个原型对象中有一个 <code>construtor</code> 属性指回构造函数</li>
<li>每个实例都有一个*<strong>*proto**</strong>属性，当我们使用构造函数去创建实例时，实例的*<strong>*proto**</strong> 属性就会指向构造函数的原型对象。</li>
</ul>
<p>用例子来理解原型链：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Dog构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"肉骨头真好吃"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用Dog构造函数创建dog实例</span></span><br><span class="line"><span class="comment">// 输出"肉骨头真好吃"</span></span><br><span class="line">dog.eat();</span><br><span class="line"><span class="comment">// 输出"[object Object]"</span></span><br><span class="line">dog.toString();</span><br></pre></td></tr></table></figure>
<p>dog 实例里并没有 eat 方法和 toString 方法，它们还是被成功地调用了。</p>
<p>因为当<strong>读取</strong>一个实例的属性/方法时，它首先搜索这个实例本身，若没找到，会向上去搜索实例的原型对象；<br>若还没找到，它就去搜索原型对象的原型对象，一直到<code>Object.prototype</code>为止，这个搜索的轨迹，就叫做 <strong>原型链</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">"green"</span>, <span class="string">"yellow"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// 此处是赋值，并不是读取，所以不会往上找</span></span><br><span class="line">b1.name = <span class="string">"change"</span>;</span><br><span class="line"><span class="comment">// b1.color是读取，如果b1上面没有，是会往上找的</span></span><br><span class="line">b1.color.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b2.name); <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(b2.color); <span class="comment">// ["green", "yellow", "black"]</span></span><br></pre></td></tr></table></figure>
<h2 id="new-做了啥"><a href="#new-做了啥" class="headerlink" title="new 做了啥"></a>new 做了啥</h2><p>实例大多是被 new 出来的。</p>
<p>那么 new 到底做了什么呢？</p>
<ul>
<li>为这个新的对象开辟一块属于它的内存空间</li>
<li>把函数体内的 this 指到 开辟的内存空间去</li>
<li>将新对象的 <code>__proto__</code>这个属性指向对应构造函数的 <code>prototype</code>属性的<strong>引用</strong>，把实例和原型对象关联起来。注意这里是<strong>引用</strong>。</li>
<li>执行函数体内的逻辑，有可能创建新对象的属性和方法</li>
<li>最后即便你没有手动 return，构造函数也会帮你把创建的这个新对象 return 出来</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">A.prototype.n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> A();</span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  n: <span class="number">2</span>,</span><br><span class="line">  m: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(b.n);</span><br><span class="line"><span class="built_in">console</span>.log(b.m);</span><br><span class="line"><span class="built_in">console</span>.log(c.n);</span><br><span class="line"><span class="built_in">console</span>.log(c.m);</span><br></pre></td></tr></table></figure>
<p>答案是<code>1 undefined 2 3</code>。</p>
<p>注意，b 实例创建的时候，构造函数的 prototype 的<strong>引用</strong>是<code>{n:1,constructor:A}</code>，所以 b 实例的<strong>proto</strong>也是指向<code>{n:1,constructor:A}</code><br>之后进行<code>A.prototype ={...}</code>，切断了和旧 prototype 的关系，<br>而 b 却仍然保留着旧 prototype 的引用。这就是造 成 b 实例和 c 实例之间表现差异的原因。</p>
<p>再看个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.a = <span class="number">1</span>;</span><br><span class="line">B.prototype.a = <span class="number">1</span>;</span><br><span class="line">C.prototype.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A().a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> B().a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> C(<span class="number">2</span>).a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这里主要注意，new 操作里，执行函数体的时候，实例会新增自己的属性和方法。</p>
<h2 id="手写实现-new"><a href="#手写实现-new" class="headerlink" title="手写实现 new"></a>手写实现 new</h2><p>new 做的事：为新对象开辟内存空间、新对象的<strong><strong>proto</strong></strong>指向构造函数的原型对象、函数体的this 指向新对象、执行函数体、函数体没有返回新对象则主动返回新对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">FnCreator, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为新对象开辟内存空间</span></span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 新对象的__proto__指向构造函数的原型对象</span></span><br><span class="line">  newObj.__proto__ = FnCreator.prototype;</span><br><span class="line">  <span class="comment">// this指向新对象、执行函数体</span></span><br><span class="line">  <span class="keyword">const</span> res = FnCreator.call(newObj, ...args);</span><br><span class="line">  <span class="comment">// 函数体没有返回新对象则主动返回新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">"object"</span> ? res : newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Dog构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"肉骨头真好吃"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建dog实例</span></span><br><span class="line"><span class="keyword">var</span> dog = myNew(Dog,<span class="string">'d'</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(dog)</span><br><span class="line"><span class="comment">// 输出"肉骨头真好吃"</span></span><br><span class="line">dog.eat();</span><br><span class="line"><span class="comment">// 输出"[object Object]"</span></span><br><span class="line">dog.toString();</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/20/exam_execute_context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/20/exam_execute_context/" itemprop="url">
                  理解执行上下文
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-20T17:15:43+08:00">
                2021-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/20/exam_execute_context/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/20/exam_execute_context/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代码一旦变多，我们就会尝试写函数、拆文件、拆模块，从而让代码更容易。</p>
<p>将庞大的问题拆分成一个个小问题的思想，叫分治（突然想到皇帝的政策）。</p>
<p>同理，JS 引擎在<strong>执行阶段</strong>，会将把<strong>庞大</strong>的执行任务划分成不同的<strong>执行上下文</strong>，降低执行的复杂度。</p>
<h2 id="执行上下文是啥"><a href="#执行上下文是啥" class="headerlink" title="执行上下文是啥"></a>执行上下文是啥</h2><p>执行上下文，简言之，“执行代码的环境”。结合分类、生命周期更易懂些。</p>
<p>执行上下文分为 3 类：</p>
<ul>
<li>全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中</li>
<li>函数上下文 —— 在函数调用时创建的上下文</li>
<li><code>eval</code>上下文 —— 笔者不用<code>eval</code>，读者也别用，问就是没用过~</li>
</ul>
<p>执行上下文的生命周期：</p>
<ul>
<li>创建阶段 —— 执行上下文的初始化状态，此时一行代码都还没有执行，只是做了一些准备工作（进栈）</li>
<li>执行阶段 —— 逐行执行脚本里的代码</li>
<li>消失阶段 – 出栈</li>
</ul>
<h2 id="全局上下文的生命周期"><a href="#全局上下文的生命周期" class="headerlink" title="全局上下文的生命周期"></a>全局上下文的生命周期</h2><p>JS 脚本运行起来之后，会第一时间创建<code>全局上下文</code>。</p>
<p>全局上下文创建阶段做的事情：</p>
<ul>
<li>创建全局对象（Window/Global）</li>
<li>创建 this ，并让它指向全局对象</li>
<li>给变量和函数安排内存空间，默认给变量赋值为 undefined；将函数声明放入内存</li>
<li><strong>创建</strong>作用域链</li>
</ul>
<p>执行阶段就开始执行代码。</p>
<p>而之前所谓的<code>变量提升</code>，只是变量的创建过程（在上下文创建阶段完成）和真实赋值过程（在上下文执行阶段完成）的不同步带来的一种错觉。</p>
<h2 id="函数上下文的生命周期"><a href="#函数上下文的生命周期" class="headerlink" title="函数上下文的生命周期"></a>函数上下文的生命周期</h2><p>和全局上下文大同小异。</p>
<p>函数上下文在函数调用的时候就会被创建。</p>
<ul>
<li>创建 arguments</li>
<li>创建 this ，并让它指向调用对象</li>
<li>给变量和函数安排内存空间，默认给变量赋值为 undefined；将函数声明放入内存</li>
<li>初始化作用域链</li>
</ul>
<p>执行阶段就开始执行代码。<br>执行完毕，就出栈了。</p>
<p>上面说到了初始化作用域链，怎么初始化？</p>
<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>JS 引擎在执行过程中，会为我们自动创建” 执行上下文栈 “（也叫调用栈）。</p>
<p>全局上下文执行栈<strong>始终</strong>在最底层。</p>
<p>调用函数的时候，函数上下文就会进栈，执行完就会出栈，也就是该上下文就结束了。</p>
<h2 id="作用域链的生命周期"><a href="#作用域链的生命周期" class="headerlink" title="作用域链的生命周期"></a>作用域链的生命周期</h2><p>参考<a href="https://github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">大神写的深入作用域链</a><br>作用域链的生命周期：</p>
<ul>
<li>全局上下文创建阶段，声明函数的时候，就保存了根据词法所生成的作用域链</li>
<li>函数调用之后，函数上下文被创建（进栈）</li>
<li>函数上下文在创建阶段，会复制这个作用域链，作为自己作用域链的初始化，然后根据环境生成变量对象，将这个变量对象，添加到这个复制的作用域链</li>
<li>函数上下文在执行阶段，会将当前作用域链的相关值更新</li>
<li>函数执行完，函数上下文出栈，刚刚复制的作用域链失效</li>
</ul>
<p>至于为什么会有两个作用域链，是因为在函数创建的时候并不能确定最终的作用域的样子，为什么会采用复制的方式而不是直接修改呢？应该是因为函数会被调用很多次吧。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope2 = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>
<p>全局上下文在创建阶段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stacks = [globalContext];</span><br><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>执行<code>checkscope()</code>这行代码的时候：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// checkscopeContext进栈</span></span><br><span class="line">stacks = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure>
<p>checkscopeContext 在创建阶段:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先复制</span></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</span></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">      <span class="built_in">arguments</span>: &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;,</span><br><span class="line">      scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: checkscope.[[scope]]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再将活动对象放在checkscope 作用域链顶端</span></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>checkscopeContext 在执行阶段:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 AO 的属性值</span></span><br><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    scope2: <span class="string">"local scope"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行完之后，checkscopeContext 出栈</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stacks = [globalContext];</span><br></pre></td></tr></table></figure>
<p>为啥，作用域在嵌套的情况下，外部作用域是不能访问内部作用域的变量呢？</p>
<p>因为当 JS 引擎位于外部上下文的时候，表明内部上下文已经出栈了，其维护的自己的作用域链也消失了，自然访问不到其变量。</p>
<h2 id="理解闭包作用域"><a href="#理解闭包作用域" class="headerlink" title="理解闭包作用域"></a>理解闭包作用域</h2><p>闭包里，虽然父作用域在父函数执行完就出栈了，但是，因为父函数执行的时候，闭包函数本身也保存了一份父函数的作用域数据，所以当闭包函数执行的时候，仍可访问到父函数的作用域数据。</p>
<p>先看这个例子，参考<a href="https://github.com/yy9306/yy9306.github.io/issues/4" target="_blank" rel="noopener">大神的深入闭包</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// checkscope执行完之后，checkscopeContext是肯定出栈的</span></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line"><span class="comment">// 那么在foo执行的时候，为什么能访问</span></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>checkscope执行完之后，checkscopeContext是肯定出栈的。</p>
<p>那为什么foo执行的时候，还能访问<code>checkscopeContext</code>？</p>
<p>联系之前的作用域生命周期来理解这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域在创建阶段：</span></span><br><span class="line">fContext.[[scope]] = [</span><br><span class="line">    checkscopeContext.VO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br><span class="line"><span class="comment">// checkscopeContext在运行阶段：</span></span><br><span class="line">fContext.[[scope]] = [</span><br><span class="line">    <span class="comment">// 此处保留了checkscopeContext的AO，也就是保留了其arguments/参数值/变量值/定义的函数</span></span><br><span class="line">    checkscopeContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br><span class="line"><span class="comment">// fContext在执行阶段：</span></span><br><span class="line">fContext = &#123;</span><br><span class="line">    <span class="comment">// 优先访问自己的AO，找不到，仍然可以访问checkscopeContext.AO</span></span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/20/exam_this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/20/exam_this/" itemprop="url">
                  努力说清this的指向和怎么改变this的指向
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-20T14:31:05+08:00">
                2021-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/20/exam_this/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/20/exam_this/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JS 中的 this，总是神神叨叨的，不小心就错了。</p>
<p>希望我自己写完本文之后，以后也按着现在捋顺的逻辑来分析 this。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>箭头函数的<code>this</code>，和它<strong>书写的位置</strong>密切相关，在书写阶段（即声明位置）就绑定到它父作用域的 <code>this</code></li>
<li>构造函数的<code>this</code>，会绑定到我们 <code>new</code> 出来的这个对象上</li>
<li>在不使用<code>call/apply/bind</code>改变<code>this</code>指向的时候，普通函数的<code>this</code>，<strong>只</strong>在调用的时候，绑定到<strong>调用方</strong>，和它的位置没有关系<ul>
<li>立即执行函数、setTimeout、setInterval 内部是<strong>普通函数</strong>的时候，因为其调用方是<code>window</code>，所以<code>this</code>是<code>window</code></li>
</ul>
</li>
<li>call/apply/bind 均可改变 this 指向，且均可被手写实现</li>
</ul>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数的<code>this</code>，和它书写的位置密切相关，在书写阶段（即声明位置）就绑定到它父作用域的 <code>this</code>。</p>
<p>因为其由父作用域决定，所以父作用域至关重要。</p>
<ul>
<li>若箭头函数的父作用域是全局作用域，则 this 始终指向<code>window</code></li>
<li>若箭头函数的父作用域是函数作用域，则指向函数作用域的<code>this</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  func2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 父作用域是全局，this始终都是window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;,</span><br><span class="line">  func3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等同于func3作用域的this</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// func1</span></span><br><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//  父作用域是全局，this任何时候都是window</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// func2</span></span><br><span class="line"><span class="keyword">var</span> func2 = obj.func2;</span><br><span class="line"><span class="comment">// func3</span></span><br><span class="line"><span class="keyword">var</span> func3 = obj.func3;</span><br><span class="line">func1();</span><br><span class="line">func2();</span><br><span class="line">func3();</span><br><span class="line">obj.func2();</span><br><span class="line">obj.func3();</span><br></pre></td></tr></table></figure>
<h2 id="构造函数里的-this"><a href="#构造函数里的-this" class="headerlink" title="构造函数里的 this"></a>构造函数里的 this</h2><p>构造函数里面的 this 会绑定到我们 new 出来的这个对象上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this是person</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"yan"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="function-定义的普通函数"><a href="#function-定义的普通函数" class="headerlink" title="function 定义的普通函数"></a>function 定义的普通函数</h2><p>function 定义的普通函数，this 的指向是在调用时决定的，而不是在书写时决定的。这点和闭包恰恰相反。</p>
<p>换言之：不管方法被书写在哪个位置，它的 this 只会跟着它的调用方走，<br>再大白话点：<code>xx.fn()</code>，点前面是谁，fn 里的 this 就是谁。没有点就是 window。</p>
<blockquote>
<p>注意上面的前提是：不使用<code>call/apply/bind</code>改变<code>this</code>指向的时候。</p>
</blockquote>
<p>必须严格区分 “声明位置” 与 “调用位置”！！！</p>
<p>上面的秘诀掌握好了，下面的例子就是 easy 了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明位置</span></span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">  name: <span class="string">"yan"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">  name: <span class="string">"xiaoming"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> targetFunc = me.hello;</span><br><span class="line">    targetFunc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"BigBear"</span>;</span><br><span class="line"><span class="comment">// 调用位置</span></span><br><span class="line">you.hello();</span><br></pre></td></tr></table></figure>
<p>还有 2 种特殊点的情景：<br>没有调用方，所以 this 始终都是<code>window</code></p>
<ul>
<li>立即执行函数（IIFE），<code>(function(){})()</code></li>
<li>setTimeout/setInterval 中传入的普通函数，<code>setTimeout(function(){...},1000)</code></li>
</ul>
<p>！！！注意，必须是 function 写的普通函数，如果箭头函数，仍遵循箭头函数的规则</p>
<p>先看个立即执行函数的例子，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"BigBear"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"yan"</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure>
<p>仔细看看就是自执行函数执行，this 肯定是 window，自然就是<code>BigBear</code>。</p>
<p>注意！！！换成箭头函数的话，规则就变了，因为父作用域是 fn，其 this 绑定成了 obj，所以打印的话是<code>yan</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn();</span><br></pre></td></tr></table></figure>
<p>再看下 setTimeout</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"BigBear"</span>;</span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">  name: <span class="string">"yan"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">me.hello();</span><br></pre></td></tr></table></figure>
<p>setTimeout 里面的函数，this 指向<code>window</code>，自然值是<code>BigBear</code>。<br>同理，如果将 setTimeout 里面的函数修改成箭头函数，则打印<code>yan</code>了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"BigBear"</span>;</span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">  name: <span class="string">"yan"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`你好，我是<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">me.hello();</span><br></pre></td></tr></table></figure>
<h2 id="严格模式下的-this"><a href="#严格模式下的-this" class="headerlink" title="严格模式下的 this"></a>严格模式下的 this</h2><p>笔者不用严格模式，真要用的时候百度下吧。</p>
<h2 id="改变-this-的指向"><a href="#改变-this-的指向" class="headerlink" title="改变 this 的指向"></a>改变 this 的指向</h2><p>this 的指向，要么被书写位置限制，要么被调用位置限制，很是被动。</p>
<ul>
<li>对于箭头函数，因为其<code>this</code>只和书写位置有关，所以一般不修改箭头函数的 this 指向。</li>
<li>构建函数，this 就是 new 出来的实例，所以一般不修改构建函数的 this 指向</li>
<li>于是重点！！！对于 function 定义的普通函数，修改 this，必须要显示的调用<code>call/apply/bind</code>。</li>
</ul>
<p>一般问的修改 this，也是指 function 定义的普通函数。</p>
<p><code>call/apply/bind</code>三者用法及区别：</p>
<ul>
<li>call/apply 改变函数的 this，且函数立即执行。但 apply 的参数是数组，call 的参数是非数组</li>
<li>bind 改变函数的 this，但函数未执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> init = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.init + num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通执行,肯定输出3</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">init</span>: <span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时因为this变成obj，所以输出103</span></span><br><span class="line">add.apply(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 此时因为this变成obj，所以输出103</span></span><br><span class="line">add.call(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 此时因为this变成obj，但需要调用一次函数才行，bind本身返回的是函数</span></span><br><span class="line">add.bind(obj, <span class="number">1</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="手写实现-call-apply-bind"><a href="#手写实现-call-apply-bind" class="headerlink" title="手写实现 call/apply/bind"></a>手写实现 call/apply/bind</h3><p>其实细看下 call，发现 call 有以下特征：</p>
<ul>
<li>call 是函数的方法，可以被函数直接调用</li>
<li>call 第一个参数是 this 绑定的对象，后面的参数是函数的参数</li>
<li>call 调用之后，函数执行，但 this 绑定到第一个参数上</li>
</ul>
<p>推理下 call 怎么实现：</p>
<ul>
<li>是函数的方法，每个函数都可调用，可写在 Function.prototype 上</li>
<li>参数区别第一个参数，和后面的参数</li>
<li>call 内，this 绑定到第一个参数上，函数执行</li>
</ul>
<p>其实想想普通函数 this 的指向只和调用方有关<br><strong>=&gt;</strong> 于是 obj.fn()<br><strong>=&gt;</strong> 但是 fn 并不是 obj 的方法<br><strong>=&gt;</strong> 于是给 obj 增加 fn 这个方法不就行了<br><strong>=&gt;</strong> 但是 call 执行完，必须再将 fn 这个方法删掉就好了  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意 这里的this就是调用call的函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 先增加</span></span><br><span class="line">  context.fn = fn;</span><br><span class="line">  <span class="comment">// 执行</span></span><br><span class="line">  <span class="keyword">return</span> fn(...args);</span><br><span class="line">  <span class="comment">// 在删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试下，没问题，输出103</span></span><br><span class="line">add.myCall(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>同理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意因为参数args就是数组，所以不要加...</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意 这里的this就是调用myApply的函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  context.fn = fn;</span><br><span class="line">  <span class="keyword">return</span> fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 同理输出103</span></span><br><span class="line">add.myApply(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>Bind 稍微复杂点：</p>
<ul>
<li>bind 是函数的方法，可以被函数直接调用</li>
<li>bind 返回一个原函数的拷贝，但 this 被指定</li>
<li>bind 也可以传原函数的部分参数</li>
</ul>
<p>其实 bind 就是返回一个函数，函数内部执行 call~</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...frontArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...behindArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(context, ...frontArgs, ...behindArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// this被指定，但是需要调用一次才能执行函数，输出103</span></span><br><span class="line">add.myBind(obj, <span class="number">1</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/19/exam_memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/19/exam_memory/" itemprop="url">
                  内存相关的知识点：
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-19T19:30:43+08:00">
                2021-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/19/exam_memory/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/19/exam_memory/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看大神写的专栏，很精辟，笔者想通过总结的方式加深理解，不一定准确，只是笔者自己的想法，欢迎指正。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>JS 的内存管理生命周期：分配、读写、释放</li>
<li>垃圾回收机制的算法：引用计数法、标记清除法</li>
<li>内存泄漏成因：闭包引起的共享父作用域、变量没声明、未清除定时器、删除不要的dom</li>
</ul>
<h2 id="JS-内存生命周期"><a href="#JS-内存生命周期" class="headerlink" title="JS 内存生命周期"></a>JS 内存生命周期</h2><p>内存管理又是是每一种编程语言都会具备的一种基本能力。</p>
<p>但有些语言暴露内存管理的方法，如 c，有些语言不暴露，如<strong>JS</strong>。</p>
<p>所以，不暴露，就不容易看见和知道了。。。</p>
<p>JS 内存生命周期，三个：</p>
<ul>
<li>“挖坑”—— 在内存空间的沃土里，划出自己的地，此举称为 “分配内存”。</li>
<li>“用坑”—— 往地里 “种菜” ：填入你需要存储的信息。此后你可以读取它，也可以更改它，此举称为 “内存的读与写” 操作。</li>
<li>“还坑”—— 用坑一时爽，但作为好公民，咱用完这个地就得及时上交给村里。这个 “还回去” 的动作，就叫做内存的释放。</li>
</ul>
<p>但挖坑的时候，得看你种啥，从而选择不同的土壤。</p>
<h2 id="1-分配内存"><a href="#1-分配内存" class="headerlink" title="1.分配内存"></a>1.分配内存</h2><p>内存分为两种：</p>
<ul>
<li>栈内存：线性表结构。适合存 基本类型：Sting、Number、Boolean、null、undefined、Symbol</li>
<li>堆内存：树结构。适合存 引用类型：Object Array 等…</li>
</ul>
<h2 id="2-读写内存"><a href="#2-读写内存" class="headerlink" title="2.读写内存"></a>2.读写内存</h2><p>栈内存和堆内存的结构不一样，所以读写的方式也不一样。</p>
<p>先看看以下是放在哪种内存里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> d = &#123; <span class="attr">name</span>: <span class="string">"修言"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> e = [<span class="string">"修言"</span>, <span class="string">"小明"</span>, <span class="string">"bear"</span>];</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a10f7f04df24bd48e995e2d6b770585~tplv-k3u1fbpfcp-zoom-1.image" alt="memory1"></p>
<p>在访问 a、b、c 三个变量时，过程非常简单：从栈中直接获取该变量的值。</p>
<p>而在访问 d 和 e 时，则需要分两步走：</p>
<ol>
<li>从栈中获取变量对应对象的引用（即它在堆内存中的地址）</li>
<li>拿着 1 中获取到的地址，再去堆内存空间查询，才能拿到我们想要的数据</li>
</ol>
<h2 id="3-释放内存"><a href="#3-释放内存" class="headerlink" title="3.释放内存"></a>3.释放内存</h2><p>JS 没有管理内存的方法，所以 JS 隔一段时间就巡查一次。<br>当<strong>判断</strong>一个变量不再被需要之后，就会把个变量所占用的内存空间给释放掉。</p>
<p>垃圾回收： 巡查 =&gt; 判断 =&gt; 释放 的过程<br>垃圾回收的算法：怎么判断变量不再被需要</p>
<p>两种判断的法子：</p>
<ul>
<li>引用计数法（已被淘汰）</li>
<li>标记清除法（正使用的）</li>
</ul>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>“引用” 这个概念，其实可以认为它描述的是变量所处那块内存的内存地址。</p>
<p>用一个变量指向了一个值，那么就创建了一个针对这个值的 “引用”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存中数组这个值有一个引用，就是student这个变量</span></span><br><span class="line"><span class="keyword">let</span> students = [<span class="string">"修言"</span>, <span class="string">"小明"</span>, <span class="string">"bear"</span>];</span><br></pre></td></tr></table></figure>
<p>在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数<br>为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果将students改成null，则上面数组的引用数就变成0了，就会被回收</span></span><br><span class="line">students = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="引用计数法的缺陷"><a href="#引用计数法的缺陷" class="headerlink" title="引用计数法的缺陷"></a>引用计数法的缺陷</h4><p>看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badCycle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cycleObj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> cycleObj2 = &#123;&#125;;</span><br><span class="line">  cycleObj1.target = cycleObj2;</span><br><span class="line">  cycleObj2.target = cycleObj1;</span><br><span class="line">&#125;</span><br><span class="line">badCycle();</span><br></pre></td></tr></table></figure>
<p>一般函数执行完，内部变量自动会被清除。<br>但是用引用计数法的话，cycleObj1 和 cycleObj2<strong>循环引用</strong>，其引用计数一直是 1，就不能被回收。</p>
<p>所以，引用计数法的缺陷是：循环引用的变量，很容易不能被回收。</p>
<h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><p>标记清除法分为两个阶段：</p>
<ul>
<li>标记阶段：垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从 根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”。</li>
<li>清除阶段： 没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除</li>
</ul>
<p>“可抵达”：意味着可以被使用</p>
<p>重新看循环引用的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badCycle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cycleObj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> cycleObj2 = &#123;&#125;;</span><br><span class="line">  cycleObj1.target = cycleObj2;</span><br><span class="line">  cycleObj2.target = cycleObj1;</span><br><span class="line">&#125;</span><br><span class="line">badCycle();</span><br></pre></td></tr></table></figure>
<p>badCycle 执行完毕后，从根对象 Window 出发，cycleObj1 和 cycleObj2 都会被识别为不可达的对象（不可被使用的对象），它们会按照 预期被清除掉。这样一来，循环引用的问题，就被标记清除干脆地解决掉了。</p>
<h2 id="闭包和内存泄露"><a href="#闭包和内存泄露" class="headerlink" title="闭包和内存泄露"></a>闭包和内存泄露</h2><p>啥是内存泄露？</p>
<blockquote>
<p>该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、 系统崩溃等一系列问题，这种现象就叫内存泄漏。</p>
</blockquote>
<p>先说一句，单纯由闭包导致的内存泄漏，极少极少（除非你的代码写得有问题）。</p>
<p>先看一段经典的闭包造成内存泄露的代码（写的有问题哈，改进就不会了）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing)</span><br><span class="line">      <span class="comment">// 'originalThing'的引用</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"嘿嘿嘿"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">"*"</span>),</span><br><span class="line">    someMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"哈哈哈"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在 V8 中，一旦不同的作用域位于同一个 父级作用域下，那么它们会共享这个父级作用域。</p>
<p>在这段代码里， unused 是一个不会被使用的闭包，但和它共享同一个父级作用域的 someMethod，则是一个 “可抵达”的闭包。<br>unused 引用了 originalThing，这导致和它共享作用域的 someMethod 也 <strong>间接</strong>地引用了 originalThing。<br>结果就是 someMethod <strong>“被迫”</strong> 产生了对 originalThing 的持续引用，originalThing 虽然 没有任何意义和作用，却永远不会被回收。<br>不仅如此，originalThing 每次 setInterval 都会改变一次指向（指向最近 一次的 theThing 赋值结果），这导致无法被回收的无用 originalThing 越堆积越多，最终导致严重的内存泄漏。</p>
<h2 id="内存泄露的原因"><a href="#内存泄露的原因" class="headerlink" title="内存泄露的原因"></a>内存泄露的原因</h2><ul>
<li><p>被迫产生对父作用域变量的引用。上面的例子。<strong>避免方案</strong>：将某个闭包多裹一层，从而不共享父作用域</p>
</li>
<li><p>在函数里，没有声明而直接赋值的变量。<strong>避免方案</strong>：变量必须声明</p>
</li>
</ul>
<p>本身想在函数内部用，用完就回收，但是因为变成了全局变量，则不会被回收</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  me = <span class="string">"yan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>忘记清除的 setInterval 和 setTimeout。<strong>避免方案</strong>：必须清定时器</li>
</ul>
<p>在 轮询调用setInterval 和链式调用的 setTimeout 这两种场景下，定时器的工作可以说都是无穷无尽的。<br>当定时器囊括的函数逻辑不再被需要、而我们又忘记手动清除定时器时，它们就会永远保持对内存的占用。</p>
<ul>
<li>清除不当的 DOM。<strong>避免方案</strong>：手动置为null。</li>
</ul>
<p>虽然删除了节点，但myDiv 这个变量对 这个 DOM 的引用仍然存在，它仍然是一块 “可抵达” 的内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMyDiv</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 一些与myDiv相关的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用myDiv</span></span><br><span class="line">handleMyDiv()</span><br><span class="line"><span class="comment">// 尝试”删除“ myDiv</span></span><br><span class="line"><span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>));</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/19/exam_scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/19/exam_scope/" itemprop="url">
                  作用域相关的知识点：闭包、LHS/RHS
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-19T12:22:33+08:00">
                2021-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/19/exam_scope/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/19/exam_scope/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看大神写的专栏，很精辟，笔者想通过总结的方式加深理解，不一定准确，只是笔者自己的想法，欢迎指正。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>作用域：存储和访问变量的规则</li>
<li>作用域链：寻找变量形成的路</li>
<li>变量提升：<code>console.log(a);var a</code>，编译器先<code>var a</code>，之后才是 JS 引擎执行<code>console.log(a)</code></li>
<li>暂时性死区：<code>let</code> 命令声明变量之前，该变量都是不可用的。上面的换成<code>let</code>就会报错。</li>
<li>执行上下文：常常是函数调用的时候，JS 引擎先做一些执行前的准备工作。</li>
<li>闭包：一个函数，使用了非自己作用域的变量。常用来私有化变量、柯里化</li>
<li>LHS/RHS：变量出现在赋值的左边，就是变量就进行了<code>LHS</code>，否则就是<code>RHS</code>(就是读取啦)</li>
<li>词法作用域：作用域链沿着它定义的位置往外延伸</li>
<li>欺骗词法作用域：eval和with</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>每一种编程语言，它最基本的能力都是能够<strong>存储</strong>变量当中的值、并且允许我们对这个变量的值进行<strong>访问</strong>和<strong>修改</strong>。</p>
<p>那么有了变量之后，应该把它<strong>放在哪里</strong>、程序<strong>如何找到</strong>它们？</p>
<p>这就需要我们提前约定好一套<strong>存储</strong>变量、<strong>访问</strong>变量的<strong>规则</strong>？这套规则，就是我们常说的作用域。</p>
<blockquote>
<p>作用域的本质：是程序存储和访问变量的规则。</p>
</blockquote>
<p>举个例子说明下<strong>规则</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 相当于：var a;a=1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>var a</code>，让<strong>编译器</strong>先在当前作用域寻找，有没有 a 的变量，有则忽略，没有则增加 a 变量</li>
<li><code>a=1</code>，让<strong>JS 执行引擎</strong>先在当前作用域寻找，有没有 a 的变量，有则赋值，<strong>没有则继续向上找</strong>，直到顶层的全局作用域，找不到就报错。</li>
</ul>
<p>以上就是规则，也就是作用域限制了存储和赋值。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>没有则继续向上找。</p>
<p>这句话，一层层向上，像链条一样的，就是作用域链。</p>
<p>顶级作用域：是全局作用域。<br>局部作用域：是函数作用域和块作用域。</p>
<p>顶级作用域就是顶层，在局部作用域里肯定可以访问顶层的作用域的变量。局部作用域则看其嵌套关系。</p>
<p>举个例子说下作用域链：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> globalAdd = addABC();</span><br><span class="line"><span class="built_in">console</span>.log(globalAdd()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>全局作用域：c、globalAdd =&gt; addABC 函数作用域：a、b =&gt; add 函数作用域：没有变量。</p>
<p>像不像链子？链子的尽头是全局作用域。</p>
<p>add 函数作用域的<strong>直接</strong>上层是 addABC 函数作用域，再往上是<strong>全局</strong>作用域。</p>
<p>所以 add 函数作用域，可以读取到<strong>a/b/c</strong>变量。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>add 函数作用域，直接访问<strong>非</strong>自己作用域的<strong>a/b/c</strong>变量，这就是闭包。</p>
<p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
<p>写高阶函数常常用到。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>引用<a href="https://juejin.cn/post/6844904158957404167" target="_blank" rel="noopener">不写 bug 的米公子</a>的话：</p>
<p>es3 中，函数被调用，在执行具体的函数代码之前，创建了执行上下文，从而进入执行上下文的创建阶段：</p>
<ul>
<li>初始化作用域链</li>
<li>创建 arguments object 检查上下文中的参数，初始化名称和值并创建引用副本</li>
<li>扫描上下文找到所有函数声明：对于每个找到的函数，用它们的原生函数名，在变量对象中创建一个属性，该属性里存放的是一个指向实际内存地址的指针。如果函数名称已经存在了，属性的引用指针将会被覆盖</li>
<li>扫描上下文找到所有 var 的变量声明：对于每个找到的变量声明，用它们的原生变量名，在变量对象中创建一个属性，并且使用 undefined 来初始化。如果变量名作为属性在变量对象中已存在，则不做任何处理并接着扫描</li>
<li>确定 this 值</li>
</ul>
<p>做完这些准备工作之后，才开始真正执行函数中的代码。</p>
<p>来个稍微复杂的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo1"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p>上面的代码，可以理解为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// 此时foo执行的时候，第一个是undefined，第二个才是2。注意这只是局部变量。</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo被重新赋值了</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo1"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// a赋值了</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有悬念的foo1</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有悬念的1</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<h2 id="LHS-RHS"><a href="#LHS-RHS" class="headerlink" title="LHS/RHS"></a>LHS/RHS</h2><p>听起来就感觉好高深。</p>
<p>其实没啥，最开始说的<strong>编辑器</strong>查找变量，如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。赋值操作会导致 LHS 查询。</p>
<p>快速速记法：L 就是 Left，R 就是 Read。（不过这两本身是 left hand side 和 right hand side。）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name出现在左边，进行赋值操作，就是对name进行了LHS</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// name被读取，就是对name进行了RHS</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="comment">// name仍然是被读取，就是对name进行了RHS</span></span><br><span class="line"><span class="comment">// newName出现在左边，进行赋值操作，就是对newName进行了LHS</span></span><br><span class="line"><span class="keyword">var</span> newName = name;</span><br></pre></td></tr></table></figure>
<p>此文写的很细致了：<a href="https://www.cnblogs.com/slly/p/9225780.html" target="_blank" rel="noopener">LHS 和 RHS—-你所不知道的JavaScript系列（1）</a></p>
<h2 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h2><p>词法作用域和动态作用域的区别其实在于划分作用域的时机：</p>
<ul>
<li>词法作用域： 在代码书写的时候完成划分，作用域链沿着它定义的位置往外延伸</li>
<li>动态作用域： 在代码运行时完成划分，作用域链沿着它的调用栈往外延伸</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"yan"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"BigBear"</span>;</span><br><span class="line">  showName();</span><br><span class="line">&#125;</span><br><span class="line">changeName();</span><br></pre></td></tr></table></figure>
<p>js 遵循的是词法作用域，所以 showName 的外层作用域是全局作用域，会打印<code>yan</code><br>如果是动态作用域，那么 showName 的外层作用域就是 changeName 函数作用域了，会打印<code>BigBear</code></p>
<h2 id="如何欺骗词法作用域"><a href="#如何欺骗词法作用域" class="headerlink" title="如何欺骗词法作用域"></a>如何欺骗词法作用域</h2><p>其实欺骗就是改变的意思，听起来又很玄学，主要就是下面的一句话。</p>
<p><code>eval</code>和<code>with</code>可以修改词法作用域，但因为这种特性，所以尽可能不要用这两个语句。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"xiuyan"</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'var name = "BigBear"'</span>;</span><br><span class="line">showName(str); <span class="comment">// 输出 BigBear</span></span><br></pre></td></tr></table></figure>
<p>eval 拿到一个字符串入参后，它会把这段字符串的内容当做一段 js 代码（不管它是不是一段 js 代码），插入自己被调用的那个位置。导致了 showName 作用域多了一个变量 name，这个是在运行时才创建的变量，所以欺骗了词法作用域。</p>
<p>with 用法有类似的功能，不再赘述（笔者偷懒不想研究了）~</p>
<h2 id="作用域的经典题目"><a href="#作用域的经典题目" class="headerlink" title="作用域的经典题目"></a>作用域的经典题目</h2><p>经典的一个题目，循环体和作用域的组合：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>结合之前的学到的，上面的代码，虚拟的等价替换下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5个setTimeout在1s后依次执行</span></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>所以很明显，打印了 6 个 5。</p>
<h2 id="三种改造方式：让-i-从-0-到-4-依次被输出"><a href="#三种改造方式：让-i-从-0-到-4-依次被输出" class="headerlink" title="三种改造方式：让 i 从 0 到 4 依次被输出"></a>三种改造方式：让 i 从 0 到 4 依次被输出</h2><p>本质：将 i 由全局变量变成局部变量，以此互不相关。</p>
<p>上面的知易行难啊。。。。。</p>
<h3 id="1-setTimeout-的第三个参数"><a href="#1-setTimeout-的第三个参数" class="headerlink" title="1. setTimeout 的第三个参数"></a>1. setTimeout 的第三个参数</h3><p>setTimeout 从第三个入参位置开始往后，是可以传 入无数个参数的。这些参数会作为回调函数的附加参数存在。</p>
<p>j 当前的作用域，是函数作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    j</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-包个函数"><a href="#2-包个函数" class="headerlink" title="2. 包个函数"></a>2. 包个函数</h3><p>虽然 i 在当前的作用域没有找到变量，但是在其外层增加一个函数作用域，也是同样的道理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-let"><a href="#3-let" class="headerlink" title="3. let"></a>3. let</h3><p>局部作用域还有一个块级作用域，异曲同工之妙。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用域特训题目"><a href="#作用域特训题目" class="headerlink" title="作用域特训题目"></a>作用域特训题目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = [];</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    num[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num[<span class="number">9</span>];</span><br><span class="line">&#125;</span><br><span class="line">test()();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test());</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">test()();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> foo(c, a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = foo(<span class="number">0</span>);</span><br><span class="line">func1.foo(<span class="number">1</span>);</span><br><span class="line">func1.foo(<span class="number">2</span>);</span><br><span class="line">func1.foo(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> func2 = foo(<span class="number">0</span>)</span><br><span class="line">  .foo(<span class="number">1</span>)</span><br><span class="line">  .foo(<span class="number">2</span>)</span><br><span class="line">  .foo(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> func3 = foo(<span class="number">0</span>).foo(<span class="number">1</span>);</span><br><span class="line">func3.foo(<span class="number">2</span>);</span><br><span class="line">func3.foo(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<!-- <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    k: <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> foo(c, a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = foo(<span class="number">0</span>);</span><br><span class="line">func1.k(<span class="number">1</span>);</span><br><span class="line">func1.k(<span class="number">2</span>);</span><br><span class="line">func1.k(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> func2 = foo(<span class="number">0</span>)</span><br><span class="line">  .k(<span class="number">1</span>)</span><br><span class="line">  .foo(<span class="number">2</span>)</span><br><span class="line">  .k(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> func3 = foo(<span class="number">0</span>).k(<span class="number">1</span>);</span><br><span class="line">func3.foo(<span class="number">2</span>);</span><br><span class="line">func3.foo(<span class="number">3</span>);</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 闭包应用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">变量只在特定的局部作用域，外部的作用域并不能访问到该变量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 私有化变量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">密码不希望被人知道`</span>user.password<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 利用闭包生成IIFE，返回 User 类</span></span><br><span class="line"><span class="keyword">const</span> User = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义私有变量_password</span></span><br><span class="line">  <span class="keyword">let</span> _password;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(username, password) &#123;</span><br><span class="line">      <span class="comment">// 初始化私有变量_password</span></span><br><span class="line">      _password = password;</span><br><span class="line">      <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    login() &#123;</span><br><span class="line">      <span class="comment">// 这里我们增加一行 console，为了验证 login 里仍可以顺利拿到密码</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.username, _password);</span><br><span class="line">      <span class="comment">// 使用 fetch 进行登录请求，同上，此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> User;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User(<span class="string">"xiuyan"</span>, <span class="string">"xiuyan123"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.username);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(user.password);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(user._password);</span><br><span class="line">user.login();</span><br></pre></td></tr></table></figure>
<h3 id="偏函数和柯里化"><a href="#偏函数和柯里化" class="headerlink" title="偏函数和柯里化"></a>偏函数和柯里化</h3><p>柯里化：是把接受 n 个参数的 1 个函数改造为只接受 1 个参数的 n 个互相嵌套的函数的过程。也就是 fn(a,b,c)会变成 f(a)(b)(c) 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateName</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">itemName</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> prefix + type + itemName;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 啥也不记，直接生成一个商品名</span></span><br><span class="line"><span class="keyword">var</span> itemFullName = generateName(<span class="string">"洗菜网"</span>)(<span class="string">"生鲜"</span>)(<span class="string">"菠菜"</span>);</span><br></pre></td></tr></table></figure>
<p>偏函数：和柯里化相似，但仅仅是把函数的入参拆解为两部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateName</span>(<span class="params">prefix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">type, itemName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prefix + type + itemName;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把3个参数分两部分传入</span></span><br><span class="line"><span class="keyword">var</span> itemFullName = generateName(<span class="string">"大卖网"</span>)(<span class="string">"母婴"</span>, <span class="string">"奶瓶"</span>);</span><br></pre></td></tr></table></figure>
-->
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/18/write-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="frontzhm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://omizt4opc.bkt.clouddn.com/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花花的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2021/01/18/write-router/" itemprop="url">
                  从0实现简易版的vuex
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-18T14:53:56+08:00">
                2021-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/18/write-router/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/18/write-router/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>想要更好的使用一个插件，可以尝试理解其实现的方式。</p>
<p>当然，了解一个优秀的插件，本身也会增强自己的能力。</p>
<p>本文，努力从零开始实现一个简易版的<code>vuex</code>，期间会用到很多编程思想，希望自己越来越灵活使用。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li><code>state</code>是响应式的，巧用Vue</li>
<li><code>getters</code>用<code>Object.defineProperty</code>实现和state的紧密相关</li>
<li><code>mutations</code>是定义<code>commit</code>方法，<code>commit</code>的this需要固定为store实例</li>
<li><code>actions</code>是定义<code>dispatch</code>，逻辑神似<code>mutations</code></li>
<li>翻到文末可以直接看<code>vuex.js</code>的简易版代码</li>
</ul>
<h2 id="vuex-的初版样子"><a href="#vuex-的初版样子" class="headerlink" title="vuex 的初版样子"></a>vuex 的初版样子</h2><p>先可以用<code>vue create xx</code>创建一个项目，不带<code>vuex</code>的。</p>
<p>先看看，如果有<code>vuex</code>插件的<code>main.js</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ecf2f1f84e64127a37fcd774b32bbb5~tplv-k3u1fbpfcp-zoom-1.image" alt="write-router1.png"></p>
<p>！！！特别注意</p>
<ul>
<li><code>{state:{},mutations:...}</code>，是用户传的参数</li>
<li>store 虽然可以<code>this.$store.state</code>，但这个 state 不完全是用户传的 state，而是处理过的 state，这两有本质区别</li>
<li>同样，用户传过来的其他属性，也会做处理，这样才有后期的<code>this.$store.getters.xx</code>等等</li>
<li>换言之，<code>store</code>就是对用户传的参数做各种处理，以方便用户操作她的数据。</li>
</ul>
<p>从这推理出<code>vuex</code>，应该具有的特征：</p>
<ul>
<li><code>Vue.use</code>表明，vuex 肯定有<code>install</code>方法</li>
<li><code>new Vuex.Store</code>表明，vuex 导出对象里，有个<code>Store</code>的类</li>
<li>每个组件内部都可以<code>this.$store</code>表明，需要注入<code>$store</code></li>
</ul>
<blockquote>
<p>如果对插件一脸懵的话，可以简单看下<a href="https://juejin.cn/post/6899639171124559886" target="_blank" rel="noopener">vue 插件的入门说明</a></p>
</blockquote>
<p>第一版<code>vuex.js</code>就出来了:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8940d961d6d847569749bdb05d5ac7f5~tplv-k3u1fbpfcp-zoom-1.image" alt="write-router2.png"></p>
<p>但这样，<code>$store</code>和<code>store实例</code>并没有挂钩，此时可以借助<code>Vue.mixins的beforeCreate钩子</code>拿到当前的 Vue 实例，从而拿到实例的<code>$options</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="comment">// 这里的this是vue的实例，其参数store就是store实例</span></span><br><span class="line">        (!Vue.prototype.$store) &amp;&amp; (Vue.prototype.$store = <span class="keyword">this</span>.$options.store;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  Store</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改进：不要轻易在原型上面添加属性，应该只在根实例有<code>store</code>的时候才设置<code>$store</code>，子实例会拿到根实例的<code>$store</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eaea0d3656b4fa9af40b063dc1e13ba~tplv-k3u1fbpfcp-zoom-1.image" alt="write-router6.png"></p>
<p><a href="https://github.com/frontzhm/write-vuex" target="_blank" rel="noopener">github源码</a> 切换到<code>c1</code>分支</p>
<h2 id="处理用户传的-state"><a href="#处理用户传的-state" class="headerlink" title="处理用户传的 state"></a>处理用户传的 state</h2><p>store 实例的<code>state</code>可以出现在视图里，值变化的时候，视图也一并更新。<br>所以，<code>state</code>是被劫持的，这里投机取巧的用下<code>Vue</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> Vue(&#123; <span class="attr">data</span>: options.state &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; $store.state.a &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.state.a++"</span>&gt;</span></span><br><span class="line">    增加</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/frontzhm/write-vuex" target="_blank" rel="noopener">github源码</a> 切换到<code>c2</code>分支</p>
<blockquote>
<p>！！！因为state是用Vue进行响应式，所有vuex重度依赖vue，不能脱离vue使用</p>
</blockquote>
<!-- TODO：state的处理需要优化 -->
<h2 id="处理用户传的-getters"><a href="#处理用户传的-getters" class="headerlink" title="处理用户传的 getters"></a>处理用户传的 getters</h2><ul>
<li>用户传的<code>getters</code>是一个函数集合</li>
<li>但是实际使用中，属性值是函数的返回值</li>
<li>属性依旧是劫持的，这边因为是函数，所以不能再投机取巧了</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex.js</span></span><br><span class="line"><span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> Vue(&#123; <span class="attr">data</span>: options.state &#125;);</span><br><span class="line">    <span class="keyword">if</span> (options.getters) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getters = &#123;&#125;;</span><br><span class="line">      <span class="built_in">Object</span>.keys(options.getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//   这里必须是属性劫持</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.getters, key, &#123;</span><br><span class="line">          get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> options.getters[key](<span class="keyword">this</span>.state);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">state: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">getters: &#123; a1(state) &#123; <span class="keyword">return</span> state.a + <span class="number">1</span>; &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123; $store.state.a &#125;&#125; &#123;&#123; $store.getters.a1 &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.state.a++"</span>&gt;</span></span><br><span class="line">    增加</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63afc3a773fc44ec894260b0ebadfba7~tplv-k3u1fbpfcp-zoom-1.image" alt="write-router1.gif"></p>
<p><a href="https://github.com/frontzhm/write-vuex" target="_blank" rel="noopener">github源码</a> 切换到<code>c3</code>分支</p>
<h2 id="处理-mutations"><a href="#处理-mutations" class="headerlink" title="处理 mutations"></a>处理 mutations</h2><p><code>mutations</code>，传的参数是一个函数集合的对象，使用的时候<code>commit(&#39;函数名&#39;,payload)</code></p>
<p>代码翻译：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">  addA(state,payload)&#123;state.a+=payload&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用的时候</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'addA'</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>由此推理出，vuex 其实写了一个<code>commit</code>方法。这个就很简单了，直接溜上来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="keyword">if</span> (options.mutations) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutations = &#123; ...options.mutations &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  commit(mutationName, ...payload) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutationName, ...payload);</span><br><span class="line">    <span class="keyword">this</span>.mutations[mutationName](<span class="keyword">this</span>.state, ...payload);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76ffc20386bc41d59111d298f5e730ef~tplv-k3u1fbpfcp-zoom-1.image" alt="write-router2.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;button @click="$store.commit('addA', 2)"&gt; 增加 &lt;/button&gt;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    a1(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.a + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    addA(state, num) &#123;</span><br><span class="line">      state.a += num;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/frontzhm/write-vuex" target="_blank" rel="noopener">github源码</a> 切换到<code>c4</code>分支</p>
<!-- 升级 -->
<h2 id="处理-actions"><a href="#处理-actions" class="headerlink" title="处理 actions"></a>处理 actions</h2><p><code>actions</code>和<code>mutations</code>是很相似的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">  <span class="comment">// 注意！！！，这里的第一个参数是store实例</span></span><br><span class="line">  addA(&#123;commit&#125;,payload)&#123;setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;commit(<span class="string">'addA'</span>,payload)&#125;,<span class="number">1000</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用的时候</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'addA'</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>这下更容易了，直接copy</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">commit(mutationName, ...payload) &#123;</span><br><span class="line">  <span class="keyword">this</span>.mutations[mutationName](<span class="keyword">this</span>.state, ...payload);</span><br><span class="line">&#125;</span><br><span class="line">dispatch(actionName, ...payload) &#123;</span><br><span class="line">  <span class="comment">// 注意这里是this，不是this.state</span></span><br><span class="line">  <span class="keyword">this</span>.actions[actionName](<span class="keyword">this</span>, ...payload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f64d0df431114042bb2f246ec9d286ad~tplv-k3u1fbpfcp-zoom-1.image" alt="write-router3.gif"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;button @click="$store.dispatch('addA', 2)"&gt; 1s后增加100 &lt;/button&gt;</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    addA(store, num) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        store.commit(<span class="string">"addA"</span>, num);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/frontzhm/write-vuex" target="_blank" rel="noopener">github源码</a> 切换到<code>c5</code>分支</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>commit做处理的时候，最好用下切片思维，这样方便修改逻辑</li>
<li>commit里面的<code>this</code>，最好固定执行store实例，因为这样在action那边的时候，可以直接解构赋值</li>
<li>action也一样</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex.js</span></span><br><span class="line"><span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (options.mutations) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutations = &#123;&#125;;</span><br><span class="line">      <span class="built_in">Object</span>.keys(options.mutations).forEach(<span class="function"><span class="params">mutationName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 切片思维，这里上下都可以加逻辑</span></span><br><span class="line">        <span class="keyword">this</span>.mutations[mutationName] = <span class="function">(<span class="params">...payload</span>) =&gt;</span> &#123;</span><br><span class="line">          options.mutations[mutationName](...payload);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将this始终执行store实例</span></span><br><span class="line">commit = <span class="function">(<span class="params">mutationName, ...payload</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.mutations[mutationName](<span class="keyword">this</span>.state, ...payload);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>action操作一样，不在赘述代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  addA(&#123;commit&#125;, num) &#123;</span><br><span class="line">    <span class="comment">// 这里可以解构了！！！</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">"addA"</span>, num);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/frontzhm/write-vuex" target="_blank" rel="noopener">github源码</a> 切换到<code>c6</code>分支。</p>
<p>还有模块空间的内容，考虑到篇幅较长，就不在本文继续了。</p>
<h2 id="附注：vuex-js的所有代码"><a href="#附注：vuex-js的所有代码" class="headerlink" title="附注：vuex.js的所有代码"></a>附注：vuex.js的所有代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> Vue(&#123; <span class="attr">data</span>: options.state &#125;);</span><br><span class="line">    <span class="keyword">if</span> (options.getters) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getters = &#123;&#125;;</span><br><span class="line">      <span class="built_in">Object</span>.keys(options.getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.getters, key, &#123;</span><br><span class="line">          get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> options.getters[key](<span class="keyword">this</span>.state);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options.mutations) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutations = &#123;&#125;;</span><br><span class="line">      <span class="built_in">Object</span>.keys(options.mutations).forEach(<span class="function"><span class="params">mutationName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mutations[mutationName] = <span class="function">(<span class="params">...payload</span>) =&gt;</span> &#123;</span><br><span class="line">          options.mutations[mutationName](...payload);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options.actions) &#123;</span><br><span class="line">      <span class="keyword">this</span>.actions = &#123;&#125;;</span><br><span class="line">      <span class="built_in">Object</span>.keys(options.actions).forEach(<span class="function"><span class="params">actionName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.actions[actionName] = <span class="function">(<span class="params">...payload</span>) =&gt;</span> &#123;</span><br><span class="line">          options.actions[actionName](...payload);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  commit = <span class="function">(<span class="params">mutationName, ...payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.mutations[mutationName](<span class="keyword">this</span>.state, ...payload);</span><br><span class="line">  &#125;;</span><br><span class="line">  dispatch = <span class="function">(<span class="params">actionName, ...payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions[actionName](<span class="keyword">this</span>, ...payload);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install(_Vue) &#123;</span><br><span class="line">    Vue = _Vue;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="comment">// 这里的this是vue的实例，其参数store就是store实例</span></span><br><span class="line">        <span class="keyword">const</span> hasStore = <span class="keyword">this</span>.$options.store;</span><br><span class="line">        <span class="comment">// 根实例的store</span></span><br><span class="line">        hasStore</span><br><span class="line">          ? (<span class="keyword">this</span>.$store = <span class="keyword">this</span>.$options.store)</span><br><span class="line">          : <span class="keyword">this</span>.$parent &amp;&amp; (<span class="keyword">this</span>.$store = <span class="keyword">this</span>.$parent.$store);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  Store</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://omizt4opc.bkt.clouddn.com/avatar.jpg"
               alt="frontzhm" />
          <p class="site-author-name" itemprop="name">frontzhm</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">262</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">54</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">frontzhm</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"frontzhm"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  

  

  

  

  


  

</body>
</html>
